<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>行動版百家樂（示範）</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:#121932;
    --panel-2:#0f1530;
    --border:#213055;
    --blue:#29a3ff;   /* 閒 */
    --red:#ff4a4a;    /* 莊 */
    --green:#37c968;  /* 和 */
    --txt:#dfe7ff;
    --muted:#8aa0c9;
    --chip:#22345e;
    --good:#2ed573;
    --bad:#ff6b6b;
    --warn:#ffcc00;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--txt);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Inter,'PingFang TC','Noto Sans TC',Arial;}
  .app{max-width:420px;margin:0 auto;min-height:100%;display:flex;flex-direction:column}

  /* 頂部影片區（用背景圖代替） + 倒數 */
  .video{
    position:relative;background:#111 url('https://images.unsplash.com/photo-1531930212218-9bb02785f13d?q=80&w=1200&auto=format&fit=crop') center/cover no-repeat;
    height:240px;border-bottom:1px solid var(--border);
  }
  .timer-badge{
    position:absolute;left:12px;top:12px;width:56px;height:56px;border-radius:50%;
    background:conic-gradient(var(--good) 0deg, var(--good) 0deg, #1b2546 0deg);
    display:grid;place-items:center;font-weight:700;font-size:18px;box-shadow:0 0 0 3px #0e1530;
  }
  .timer-badge span{filter:drop-shadow(0 2px 2px rgba(0,0,0,.45))}
  .labels{
    position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;padding:8px 10px;gap:8px;
  }
  .lbl{
    flex:1;display:flex;align-items:center;justify-content:center;height:30px;border-radius:16px;background:#1a2448;
    font-weight:800;letter-spacing:.5px
  }
  .lbl.blue{background:linear-gradient(#1483db,#1c97ff)}
  .lbl.red{background:linear-gradient(#ff3a3a,#ff5b5b)}
  .lbl .score{margin-left:8px;font-size:16px}
  .lbl .name{font-size:12px;opacity:.95}

  /* 牌桌（置中） */
  .table{
    position:absolute;left:0;right:0;bottom:8px;margin:auto;width:94%;
    background:rgba(10,15,30,.55);backdrop-filter:blur(4px);
    border:1px solid rgba(255,255,255,.06);border-radius:10px;padding:8px 10px;
  }
  .cards{display:flex;justify-content:space-between;gap:10px}
  .side{flex:1;display:flex;justify-content:center;gap:6px}
  .side .tag{position:absolute;margin-top:-18px;font-size:12px;opacity:.9}
  .card{
    width:52px;height:70px;border-radius:6px;background:#fff;display:grid;place-items:center;
    color:#000;font-weight:800;border:1px solid #cfd6e4;box-shadow:0 2px 6px rgba(0,0,0,.25)
  }
  .card .s{font-size:12px}
  .card.r{color:#e6002d}
  .small{transform:scale(.85)}
  .hidden{visibility:hidden}

  /* 餘額 + 控制列 */
  .wallet{
    background:var(--panel);border-top:1px solid var(--border);padding:8px 10px;display:flex;align-items:center;justify-content:space-between
  }
  .wallet .bal{font-weight:800}
  .wallet .ctl{display:flex;gap:8px}
  .btn{
    height:32px;min-width:68px;border:1px solid var(--border);border-radius:8px;background:var(--panel-2);color:var(--txt);
    display:grid;place-items:center;font-weight:700
  }
  .btn.ok{background:var(--good);border-color:var(--good);color:#06210f}
  .btn.cancel{background:#243455}
  .btn:disabled{opacity:.5}

  /* 下注區 */
  .bets{
    background:var(--panel);border-top:1px solid var(--border);padding:8px 8px
  }
  .bet-grid{
    display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;margin-bottom:8px
  }
  .bet{
    height:56px;border-radius:8px;background:var(--panel-2);border:1px solid var(--border);
    display:flex;align-items:center;justify-content:center;font-weight:900;letter-spacing:.5px;position:relative
  }
  .bet.blue{outline:2px solid rgba(41,163,255,.2)}
  .bet.red{outline:2px solid rgba(255,74,74,.2)}
  .bet.green{outline:2px solid rgba(55,201,104,.2)}
  .bet .amt{
    position:absolute;right:6px;bottom:4px;font-size:12px;color:var(--warn);font-weight:800
  }

  /* 籌碼 */
  .chips{display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
  .chip{
    width:52px;height:52px;border-radius:50%;display:grid;place-items:center;border:3px solid #fff1;
    background:radial-gradient(circle at 30% 30%,#3a5388 0%,#203459 60%,#1a2b4f 100%);cursor:pointer;
    color:#fff;font-weight:900;box-shadow:inset 0 0 0 4px #1f2e52,0 2px 6px rgba(0,0,0,.35)
  }
  .chip.sel{box-shadow:inset 0 0 0 4px #d4b106,0 0 0 3px #d4b10666,0 6px 10px rgba(0,0,0,.4)}

  /* 牌路區（加大） */
  .roads{
    background:#0a1228;border-top:1px solid var(--border);padding:8px;display:grid;grid-template-columns:98px 1fr;gap:8px
  }
  .board{
    background:#0d1734;border:1px solid var(--border);border-radius:8px;padding:6px;display:grid;gap:4px
  }
  .bead{
    grid-template-columns:repeat(12,1fr);
    grid-auto-rows:22px; /* 固定格子高度 */
  }
  .big{
    grid-template-columns:repeat(48,1fr);
    grid-auto-rows:22px;
  }
  .cell{
    position:relative;background:#0f1b3d;border:1px solid #162653;border-radius:4px;display:grid;place-items:center;overflow:hidden
  }
  .dot{width:14px;height:14px;border-radius:50%}
  .dot.p{background:var(--blue)}
  .dot.b{background:var(--red)}
  .tie-slash{
    position:absolute;width:150%;height:2px;background:var(--green);transform:rotate(45deg)
  }
  .legend{font-size:12px;color:var(--muted);display:flex;gap:8px;align-items:center;margin-top:2px}
  .legend span::before{content:"";display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:4px;vertical-align:-1px}
  .legend .p::before{background:var(--blue)}
  .legend .b::before{background:var(--red)}
  .legend .t::before{background:var(--green)}
</style>
</head>
<body>
<div class="app">

  <!-- 影片 + 倒數 + 牌桌 -->
  <div class="video" id="video">
    <div class="labels">
      <div class="lbl blue"><span class="name">PLAYER</span><span class="score" id="pScore">0</span></div>
      <div class="lbl red"><span class="name">BANKER</span><span class="score" id="bScore">0</span></div>
    </div>
    <div class="timer-badge" id="timer"><span id="sec">15</span></div>
    <div class="table">
      <div class="cards">
        <div class="side" id="pSide">
          <div class="card" id="p1"></div>
          <div class="card" id="p2"></div>
          <div class="card small hidden" id="p3"></div>
        </div>
        <div class="side" id="bSide">
          <div class="card" id="b1"></div>
          <div class="card" id="b2"></div>
          <div class="card small hidden" id="b3"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- 餘額 + 確認/取消 -->
  <div class="wallet">
    <div class="bal">餘額：<span id="balance">100000</span></div>
    <div class="ctl">
      <button class="btn cancel" id="btnCancel">取消下注</button>
      <button class="btn ok" id="btnConfirm">確認下注</button>
    </div>
  </div>

  <!-- 下注區 -->
  <div class="bets">
    <div class="bet-grid">
      <div class="bet blue"   data-bet="player">閒 <span class="amt" id="amt-player">0</span></div>
      <div class="bet green"  data-bet="tie">和 <span class="amt" id="amt-tie">0</span></div>
      <div class="bet red"    data-bet="banker">莊 <span class="amt" id="amt-banker">0</span></div>

      <div class="bet blue"   data-bet="ppair">閒對 <span class="amt" id="amt-ppair">0</span></div>
      <div class="bet"        data-bet="super6">超級六 <span class="amt" id="amt-super6">0</span></div>
      <div class="bet red"    data-bet="bpair">莊對 <span class="amt" id="amt-bpair">0</span></div>
    </div>

    <div class="chips" id="chips"></div>
  </div>

  <!-- 牌路 -->
  <div class="roads">
    <div>
      <div class="legend">
        <span class="p">閒</span><span class="b">莊</span><span class="t">和</span>
      </div>
      <div class="board bead" id="bead"></div>
    </div>
    <div>
      <div class="legend">
        <span class="p">大路規則：同結果往下；換色往右；和在原點畫綠斜線</span>
      </div>
      <div class="board big" id="big"></div>
    </div>
  </div>

</div>

<script>
/* ===================== 工具 ===================== */
const $ = sel => document.querySelector(sel);
const $$ = sel => document.querySelectorAll(sel);
function fmt(n){ return Number(n).toLocaleString('zh-Hant'); }

/* ===================== 狀態 ===================== */
const ST = {BET:0, REVEAL:1};
let phase = ST.BET;
let balance = 100000;
const MIN = 100, MAX = 100000;
const CHIP_VALUES = [100,500,1000,5000,10000,50000];
let selectedChip = CHIP_VALUES[0];

const pending = {player:0, banker:0, tie:0, ppair:0, bpair:0, super6:0};
const locked  = {player:0, banker:0, tie:0, ppair:0, bpair:0, super6:0};

const odds = {
  player: 1.0,
  banker: 0.95,
  tie:    8.0,
  ppair: 11.0,
  bpair: 11.0,
  super6:12.0  // 莊6獲勝
};

function refreshBalance(){ $('#balance').textContent = fmt(balance); }
function updateAmounts(){
  Object.keys(pending).forEach(k=>{
    $('#amt-'+k).textContent = fmt(pending[k]+locked[k]);
  });
}

/* ===================== 籌碼UI ===================== */
function renderChips(){
  const box = $('#chips');
  box.innerHTML = '';
  CHIP_VALUES.forEach(v=>{
    const d = document.createElement('div');
    d.className = 'chip'+(v===selectedChip?' sel':'');
    d.textContent = v>=1000 ? (v/1000)+'K' : v;
    d.onclick = ()=>{
      selectedChip = v;
      $$('.chip').forEach(c=>c.classList.remove('sel'));
      d.classList.add('sel');
    };
    box.appendChild(d);
  });
}
renderChips();

/* ===================== 下注 ===================== */
function canStake(add){
  const totalPending = Object.values(pending).reduce((a,b)=>a+b,0);
  return (balance - totalPending - add) >= 0;
}
function addBet(k){
  if (phase!==ST.BET) return;
  if (selectedChip < MIN || selectedChip > MAX) return;
  if (!canStake(selectedChip)) return;
  pending[k] += selectedChip;
  updateAmounts();
}
$$('.bet').forEach(b=>{
  b.onclick = ()=> addBet(b.dataset.bet);
});
$('#btnCancel').onclick = ()=>{
  if (phase!==ST.BET) return;
  // 只取消未確認的
  Object.keys(pending).forEach(k=> pending[k]=0);
  updateAmounts();
};
$('#btnConfirm').onclick = ()=>{
  if (phase!==ST.BET) return;
  // 檢查限紅 & 餘額
  let sum = 0;
  Object.keys(pending).forEach(k=>{
    if (pending[k] > MAX) pending[k] = MAX;
    sum += pending[k];
  });
  if (sum>0 && balance >= sum){
    balance -= sum;
    Object.keys(locked).forEach(k=> locked[k]+=pending[k]);
    Object.keys(pending).forEach(k=> pending[k]=0);
    refreshBalance(); updateAmounts();
  }
};

/* ===================== 倒數 + 流程 ===================== */
const SEC_BET = 15, SEC_REVEAL = 5;
let left = SEC_BET;   // 倒數秒
const timer = $('#timer'), secText=$('#sec');

function drawTimer(){
  const total = (phase===ST.BET)?SEC_BET:SEC_REVEAL;
  const deg = Math.round((left/total)*360);
  timer.style.background = `conic-gradient(${phase===ST.BET?'var(--good)':'var(--warn)'} ${deg}deg, #1b2546 0deg)`;
  secText.textContent = String(left);
}

let iv = null;
function startRound(){
  // 重置卡面
  resetCards();
  // 進入下注
  phase = ST.BET;
  left = SEC_BET; drawTimer();
  iv && clearInterval(iv);
  iv = setInterval(tick,1000);
}
function tick(){
  left--; if (left<0) left=0; drawTimer();
  if (phase===ST.BET && left===0){
    // 未確認自動取消
    Object.keys(pending).forEach(k=> pending[k]=0);
    updateAmounts();
    // 進入開牌
    phase = ST.REVEAL; left = SEC_REVEAL; drawTimer();
    dealAndReveal();   // 補牌與顯示
  }else if (phase===ST.REVEAL && left===0){
    settle();          // 結算
    startRound();      // 下一局
  }
}

/* ===================== 發牌/補牌 ===================== */
const ranks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
const suits = ['♣','♦','♥','♠'];
function drawCard(){
  const r = ranks[Math.floor(Math.random()*13)];
  const s = suits[Math.floor(Math.random()*4)];
  const val = (r==='A')?1:(r==='K'||r==='Q'||r==='J'||r==='10')?0:parseInt(r,10);
  return {r,s,val};
}
function baccaratTotal(vals){ return (vals.reduce((a,b)=>a+b,0))%10; }

function setCard(el,c){
  el.classList.toggle('r', (c.s==='♦'||c.s==='♥'));
  el.innerHTML = `<div>${c.r}</div><div class="s">${c.s}</div>`;
  el.classList.remove('hidden');
}

function resetCards(){
  ['p1','p2','p3','b1','b2','b3'].forEach(id=>{
    const el = $('#'+id); el.innerHTML=''; el.classList.add('hidden');
  });
  $('#pScore').textContent='0';
  $('#bScore').textContent='0';
}

/* 百家樂補牌規則 */
function dealAndReveal(){
  const P=[], B=[];
  // 兩張起手
  P.push(drawCard()); B.push(drawCard());
  P.push(drawCard()); B.push(drawCard());
  // 顯示兩張
  setCard($('#p1'), P[0]); setCard($('#p2'), P[1]);
  setCard($('#b1'), B[0]); setCard($('#b2'), B[1]);
  updateScore();

  const pTot = ()=> baccaratTotal(P.map(x=>x.val));
  const bTot = ()=> baccaratTotal(B.map(x=>x.val));

  // 自然牌
  if (pTot()>=8 || bTot()>=8){
    afterDealt(P,B); return;
  }

  let pThird = null;
  // 閒第三張規則
  if (pTot()<=5){
    pThird = drawCard();
    P.push(pThird);
    setCard($('#p3'),pThird);
  }

  // 莊第三張規則
  let drawBanker = false;
  if (!pThird){ // 閒未抓
    if (bTot()<=5) drawBanker = true;
  }else{
    const pv = pThird.val;
    const bt = bTot();
    if      (bt<=2) drawBanker = true;
    else if (bt===3 && pv!==8) drawBanker = true;
    else if (bt===4 && (pv>=2 && pv<=7)) drawBanker = true;
    else if (bt===5 && (pv>=4 && pv<=7)) drawBanker = true;
    else if (bt===6 && (pv===6 || pv===7)) drawBanker = true;
  }
  if (drawBanker){
    B.push(drawCard());
    setCard($('#b3'),B[2]);
  }

  afterDealt(P,B);
}

function updateScore(){
  const pvals = ['p1','p2','p3'].map(id=>{
    const el = $('#'+id); if (el.classList.contains('hidden')) return null;
    const txt = el.textContent.trim(); // 粗略
    if (!txt) return null;
    return 0; // 此處實際得分已在 afterDealt 計算，這裡只做即時顯示時再計
  });
}

function afterDealt(P,B){
  const p = (P.map(x=>x.val).reduce((a,b)=>a+b,0))%10;
  const b = (B.map(x=>x.val).reduce((a,b)=>a+b,0))%10;
  $('#pScore').textContent = p;
  $('#bScore').textContent = b;

  let result = null; // 'p' | 'b' | 't'
  if (p>b) result='p';
  else if (b>p) result='b';
  else result='t';

  // 牌路寫入
  writeBead(result);
  writeBig(result);

  // 保存給結算使用
  lastOutcome = {result, P, B, p, b};
}

/* ===================== 結算 ===================== */
let lastOutcome = null;
function winAmt(side){
  const o = lastOutcome;
  if (!o) return 0;
  let w = 0;

  // 主注
  if (o.result==='p') w += locked.player * (1+odds.player);
  if (o.result==='b') {
    // 若選了 super6 且莊點數=6 且莊勝：super6中
    if (o.b===6) w += locked.super6 * (1+odds.super6);
    w += locked.banker * (1+odds.banker);
  }
  if (o.result==='t') {
    // 主注退還，和注賠付
    w += (locked.player + locked.banker); // 退本
    w += locked.tie * (1+odds.tie);
  }

  // 對子（兩張前兩張）
  const pPair = (o.P[0].r === o.P[1].r);
  const bPair = (o.B[0].r === o.B[1].r);
  if (pPair) w += locked.ppair * (1+odds.ppair);
  if (bPair) w += locked.bpair * (1+odds.bpair);

  return w;
}
function settle(){
  const paid = winAmt();
  balance += paid;
  refreshBalance();

  // 清空已鎖注
  Object.keys(locked).forEach(k=> locked[k]=0);
  updateAmounts();
}

/* ===================== 珠盤 ===================== */
const BEAD_ROWS = 6, BEAD_COLS = 12;
const beadGrid = $('#bead');
for (let r=0;r<BEAD_ROWS;r++){
  for (let c=0;c<BEAD_COLS;c++){
    const d = document.createElement('div'); d.className='cell'; d.dataset.r=r; d.dataset.c=c;
    beadGrid.appendChild(d);
  }
}
let beadIndex = 0; // 0..(BEAD_ROWS*BEAD_COLS-1)
function beadCell(c,r){ return beadGrid.querySelector(`.cell[data-c="${c}"][data-r="${r}"]`); }
function writeBead(mark){
  // 由上往下，滿一欄換下一欄
  const col = Math.floor(beadIndex/BEAD_ROWS);
  const row = beadIndex%BEAD_ROWS;
  if (col >= BEAD_COLS){
    // 左捲：把整盤往左搬一欄
    for (let r=0;r<BEAD_ROWS;r++){
      for (let c=0;c<BEAD_COLS-1;c++){
        const to = beadGrid.querySelector(`.cell[data-c="${c}"][data-r="${r}"]`);
        const from = beadGrid.querySelector(`.cell[data-c="${c+1}"][data-r="${r}"]`);
        to.innerHTML = from.innerHTML;
      }
      const last = beadGrid.querySelector(`.cell[data-c="${BEAD_COLS-1}"][data-r="${r}"]`);
      last.innerHTML='';
    }
    beadIndex = (BEAD_COLS-1)*BEAD_ROWS; // 最右欄最上
  }
  const c = Math.floor(beadIndex/BEAD_ROWS);
  const r = beadIndex%BEAD_ROWS;
  const cell = beadGrid.querySelector(`.cell[data-c="${c}"][data-r="${r}"]`);
  const d = document.createElement('div');
  d.className = 'dot ' + (mark==='p'?'p':mark==='b'?'b':'t');
  cell.innerHTML=''; cell.appendChild(d);
  beadIndex++;
}

/* ===================== 大路（固定格子：同色往下、換色往右） ===================== */
const BIG_ROWS=6, BIG_COLS=48;
const bigGrid = $('#big');
for (let r=0;r<BIG_ROWS;r++){
  for (let c=0;c<BIG_COLS;c++){
    const d = document.createElement('div'); d.className='cell'; d.dataset.r=r; d.dataset.c=c;
    bigGrid.appendChild(d);
  }
}
function cellEl(board,c,r){ return board.querySelector(`.cell[data-c="${c}"][data-r="${r}"]`); }

const bigData = [...Array(BIG_COLS)].map(()=>Array(BIG_ROWS).fill(null));
let bigCol=0,bigRow=0,lastMain=null;
const bigSeq=[];

function shiftGridLeft(board){
  // 將畫面往左搬一欄
  for (let r=0;r<BIG_ROWS;r++){
    for (let c=0;c<BIG_COLS-1;c++){
      const to = cellEl(board,c,r);
      const from = cellEl(board,c+1,r);
      to.innerHTML = from.innerHTML;
    }
    cellEl(board,BIG_COLS-1,r).innerHTML='';
  }
}

function shiftAllRoadsLeft(){
  shiftGridLeft(bigGrid);
  bigData.splice(0,1);
  bigData.push(Array(BIG_ROWS).fill(null));
  bigCol = Math.max(0,bigCol-1);
  for (let i=0;i<bigSeq.length;i++) bigSeq[i].c--;
  while (bigSeq.length && bigSeq[0].c<0) bigSeq.shift();
}

function placeAt(c,r,mark){
  if (c>=BIG_COLS){ shiftAllRoadsLeft(); c=BIG_COLS-1; }
  bigCol=c; bigRow=r; bigData[c][r]=mark;
  const cell = cellEl(bigGrid,c,r);
  const d = document.createElement('div'); d.className='dot '+mark;
  cell.innerHTML=''; cell.appendChild(d);
}
function writeBig(mark){
  if (mark==='t'){ // 和：在目前點劃綠斜線
    const cell = cellEl(bigGrid,bigCol,bigRow);
    if (cell){
      const s=document.createElement('div'); s.className='tie-slash';
      cell.appendChild(s);
    }
    bigSeq.push({c:bigCol,r:bigRow,side:'t'});
    return;
  }
  if (lastMain===null){
    lastMain=mark; placeAt(0,0,mark);
    bigSeq.push({c:bigCol,r:bigRow,side:mark}); return;
  }
  if (mark===lastMain){
    // 同色 → 往下；若被占用改往右同列（持續找空格）
    let c=bigCol, r=bigRow+1;
    if (r<BIG_ROWS && !bigData[c][r]){
      placeAt(c,r,mark);
    }else{
      c=bigCol+1; r=bigRow;
      while (c<BIG_COLS && bigData[c] && bigData[c][r]) c++;
      placeAt(c,r,mark);
    }
  }else{
    // 換色 → 下一欄從上到下找第一個空格
    lastMain=mark;
    let c=bigCol+1, r=0;
    while (c<BIG_COLS && bigData[c] && bigData[c][r]) { r++; if (r>=BIG_ROWS){ c++; r=0; } }
    placeAt(c,r,mark);
  }
  bigSeq.push({c:bigCol,r:bigRow,side:mark});
}

/* ===================== 初始化 ===================== */
function initBeadGridLabels(){
  // 為了珠盤固定欄位：加 data-c
  const cells = $('#bead').querySelectorAll('.cell');
  let idx=0;
  for (let c=0;c<BEAD_COLS;c++){
    for (let r=0;r<BEAD_ROWS;r++){
      const cell=cells[idx++]; cell.dataset.c=c; cell.dataset.r=r;
    }
  }
}
function initBigGridLabels(){
  const cells = $('#big').querySelectorAll('.cell');
  let idx=0;
  for (let c=0;c<BIG_COLS;c++){
    for (let r=0;r<BIG_ROWS;r++){
      const cell=cells[idx++]; cell.dataset.c=c; cell.dataset.r=r;
    }
  }
}
initBeadGridLabels();
initBigGridLabels();
refreshBalance(); updateAmounts(); drawTimer(); startRound();
</script>
</body>
</html>
