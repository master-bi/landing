<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>紅方塊下落遊戲</title>
<style>
  html,body{height:100%;margin:0;padding:0;background:#111;color:#eee;display:grid;place-items:center;font-family:sans-serif;}
  canvas{background:linear-gradient(#1a1a1a,#0a0a0a);border:2px solid #333;border-radius:10px;}
  h1{font-size:20px;margin-bottom:6px;text-align:center;color:#e5e5e5;}
</style>
</head>
<body>
  <div>
    <h1>紅方塊下落 - 藍方塊閃避</h1>
    <canvas id="game" width="360" height="480"></canvas>
  </div>

<script>
const cvs = document.getElementById('game');
const ctx = cvs.getContext('2d');

let player = {x:160,y:420,w:40,h:40,color:'#3b82f6',speed:5};
let enemies = [];
let score = 0;
let gameOver = false;

function spawnEnemy(){
  const size = 30 + Math.random()*20;
  const x = Math.random()*(cvs.width - size);
  enemies.push({x,y: -size,w:size,h:size,speed:2+Math.random()*3,color:'#ef4444'});
}

function drawRect(o){
  ctx.fillStyle = o.color;
  ctx.fillRect(o.x,o.y,o.w,o.h);
}

function resetGame(){
  enemies = [];
  score = 0;
  gameOver = false;
  player.x = 160;
}

function loop(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  if(Math.random()<0.03) spawnEnemy();

  // 更新敵人
  for(let e of enemies){
    e.y += e.speed;
  }
  enemies = enemies.filter(e => e.y < cvs.height + e.h);

  // 碰撞檢測
  for(let e of enemies){
    if(e.x < player.x + player.w && e.x + e.w > player.x && e.y < player.y + player.h && e.y + e.h > player.y){
      gameOver = true;
    }
  }

  // 控制
  if(keys['ArrowLeft'] || keys['a']) player.x -= player.speed;
  if(keys['ArrowRight']|| keys['d']) player.x += player.speed;
  player.x = Math.max(0,Math.min(cvs.width-player.w,player.x));

  // 畫背景網格
  ctx.fillStyle='#1f1f1f';
  for(let i=0;i<cvs.width;i+=20){ctx.fillRect(i,0,1,cvs.height);}
  for(let j=0;j<cvs.height;j+=20){ctx.fillRect(0,j,cvs.width,1);}

  // 畫角色與敵人
  drawRect(player);
  enemies.forEach(drawRect);

  // 畫分數
  ctx.fillStyle='#ccc';
  ctx.font='16px sans-serif';
  ctx.fillText('Score: '+Math.floor(score),10,20);

  if(!gameOver){
    score += 0.5;
    requestAnimationFrame(loop);
  } else {
    ctx.fillStyle='rgba(0,0,0,0.6)';
    ctx.fillRect(0,0,cvs.width,cvs.height);
    ctx.fillStyle='#f87171';
    ctx.font='24px sans-serif';
    ctx.textAlign='center';
    ctx.fillText('💥 GAME OVER 💥',cvs.width/2,cvs.height/2-10);
    ctx.fillStyle='#ccc';
    ctx.font='16px sans-serif';
    ctx.fillText('按空白鍵或點擊重來',cvs.width/2,cvs.height/2+20);
  }
}

const keys={};
document.addEventListener('keydown',e=>{
  keys[e.key]=true;
  if(e.key===' '&&gameOver){resetGame();loop();}
});
document.addEventListener('keyup',e=>keys[e.key]=false);

// 手機操作
cvs.addEventListener('touchstart',e=>{
  const x = e.touches[0].clientX - cvs.getBoundingClientRect().left;
  if(x < cvs.width/2) player.x -= player.speed*2;
  else player.x += player.speed*2;
});

loop();
</script>
</body>
</html>
