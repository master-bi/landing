<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>躲避方塊｜Web 小遊戲</title>
<style>
  :root {
    --bg:#0b1220; --fg:#e2e8f0; --accent:#38bdf8; --danger:#f43f5e; --muted:#94a3b8;
  }
  *{box-sizing:border-box} html,body{height:100%;margin:0}
  body{
    display:grid;place-items:center;background:radial-gradient(1200px 600px at 50% -10%, #0f1a2f 0%, var(--bg) 60%);
    color:var(--fg); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; 
  }
  .wrap{width:min(92vw,720px)}
  header{display:flex;justify-content:space-between;align-items:center;margin:12px 0}
  h1{font-size:18px;margin:0;color:#e5f2ff;letter-spacing:.06em}
  .stats{display:flex;gap:14px;font-weight:600}
  .chip{padding:6px 10px;border-radius:999px;background:#0f1f38;color:#cde7ff;border:1px solid #153052}
  .btn{appearance:none;border:1px solid #284e7a;background:#0e223e;color:#dff2ff;border-radius:10px;
       padding:10px 14px;font-weight:700;cursor:pointer;transition:.2s}
  .btn:hover{filter:brightness(1.15)} .btn:active{transform:translateY(1px)}
  canvas{width:100%;height:auto;background:linear-gradient(#0b1a2b,#0a1321);border:1px solid #1f2f4a;border-radius:16px}
  .hint{margin:10px 4px;color:var(--muted);font-size:13px}
  .toast{
    position:fixed; inset:0; display:none; place-items:center; background:rgba(2,6,23,.65); backdrop-filter:blur(4px);
  }
  .toast.show{display:grid}
  .card{width:min(92vw,420px); background:#0d1b2f; border:1px solid #1e3353; border-radius:16px; padding:18px}
  .card h2{margin:0 0 6px 0; font-size:20px}
  .row{display:flex;justify-content:space-between;align-items:center;margin-top:10px}
  .kbd{background:#0b223b;border:1px solid #24476e;padding:2px 6px;border-radius:6px;color:#cde7ff;font-weight:700}
  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-top:12px}
  .btn-accent{background:var(--accent);border-color:#2ea6e1;color:#06121f}
  .btn-danger{background:var(--danger);border-color:#e02449}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>躲避方塊</h1>
      <div class="stats">
        <div class="chip">分數 <span id="score">0</span></div>
        <div class="chip">最佳 <span id="best">0</span></div>
      </div>
      <button id="btnPause" class="btn">暫停</button>
    </header>

    <canvas id="game" width="720" height="420" aria-label="Game Canvas"></canvas>

    <div class="hint">鍵盤：<span class="kbd">WASD</span> 或 <span class="kbd">方向鍵</span>；手機：點擊畫面左/右半邊移動。躲開紅色方塊，活得越久分數越高！</div>
  </div>

  <!-- 遊戲結束 / 暫停面板 -->
  <div id="overlay" class="toast" role="dialog" aria-modal="true">
    <div class="card">
      <h2 id="ovTitle">遊戲暫停</h2>
      <div id="ovMsg" style="color:#cbd5e1">再接再厲！</div>
      <div class="row">
        <div>分數 <strong id="ovScore">0</strong></div>
        <div>最佳 <strong id="ovBest">0</strong></div>
      </div>
      <div class="grid">
        <button id="btnResume" class="btn btn-accent">繼續</button>
        <button id="btnRestart" class="btn btn-danger">重新開始</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const cvs = document.getElementById('game'), ctx = cvs.getContext('2d');
  const scoreEl = document.getElementById('score'), bestEl = document.getElementById('best');
  const overlay = document.getElementById('overlay'), btnPause = document.getElementById('btnPause');
  const btnResume = document.getElementById('btnResume'), btnRestart = document.getElementById('btnRestart');
  const ovTitle = document.getElementById('ovTitle'), ovMsg = document.getElementById('ovMsg');
  const ovScore = document.getElementById('ovScore'), ovBest = document.getElementById('ovBest');

  // 遊戲狀態
  let running = true, gameOver = false, score = 0, best = +localStorage.getItem('best-dodge') || 0;
  bestEl.textContent = best;

  // 角色
  const player = { x: cvs.width/2, y: cvs.height-60, w: 22, h: 22, speed: 4.2, vx:0 };
  const enemies = []; // {x,y,w,h,vx,vy}

  // 工具
  const rnd = (a,b)=>Math.random()*(b-a)+a;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const hit = (a,b)=>!(a.x+a.w<b.x||b.x+b.w<a.x||a.y+a.h<b.y||b.y+b.h<a.y);

  // 生成敵人
  function spawnEnemy() {
    const size = rnd(14, 32);
    const fromLeft = Math.random() < .5;
    const x = fromLeft ? -size : cvs.width+size;
    const y = rnd(40, cvs.height*0.6);
    const speed = rnd(1.8, 3.6) * (fromLeft ? 1 : -1);
    enemies.push({x, y, w:size, h:size, vx: speed, vy: rnd(.1,.35) });
  }

  // 背景電路線
  function drawCircuitBG() {
    ctx.save();
    ctx.globalAlpha = .25;
    ctx.strokeStyle = '#153a61';
    ctx.lineWidth = 2;
    const step = 48;
    for(let x=24;x<cvs.width;x+=step){
      ctx.beginPath();
      ctx.moveTo(x, 20);
      ctx.lineTo(x, rnd(60,120));
      ctx.stroke();
    }
    for(let i=0;i<6;i++){
      ctx.beginPath();
      ctx.moveTo(rnd(0,cvs.width*.3), rnd(80,160));
      ctx.lineTo(rnd(cvs.width*.3,cvs.width*.7), rnd(80,160));
      ctx.lineTo(rnd(cvs.width*.7,cvs.width), rnd(120,220));
      ctx.stroke();
    }
    ctx.restore();
  }

  // 畫玩家與敵人
  function drawPlayer() {
    // 外光暈
    ctx.shadowBlur = 16; ctx.shadowColor = 'rgba(56,189,248,.6)';
    ctx.fillStyle = '#38bdf8';
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.shadowBlur = 0;
    // 邊框
    ctx.strokeStyle = '#e2f3ff'; ctx.lineWidth = 1.2;
    ctx.strokeRect(player.x+.5, player.y+.5, player.w-1, player.h-1);
  }
  function drawEnemy(e) {
    ctx.shadowBlur = 12; ctx.shadowColor = 'rgba(244,63,94,.55)';
    ctx.fillStyle = '#f43f5e';
    ctx.fillRect(e.x, e.y, e.w, e.h);
    ctx.shadowBlur = 0;
  }

  // 控制
  const keys={};
  addEventListener('keydown',e=>{keys[e.key]=true; if(['ArrowLeft','ArrowRight',' ','Escape'].includes(e.key)) e.preventDefault();});
  addEventListener('keyup',  e=>{keys[e.key]=false;});
  // 觸控：左半邊左移、右半邊右移
  cvs.addEventListener('touchstart',e=>{
    const x = e.changedTouches[0].clientX - cvs.getBoundingClientRect().left;
    player.vx = x < cvs.clientWidth/2 ? -player.speed : player.speed;
  });
  cvs.addEventListener('touchend',()=>{player.vx=0;});

  // 暫停/恢復/重來
  function setPause(p){
    running=!p;
    overlay.classList.toggle('show', p);
    ovTitle.textContent = gameOver ? '遊戲結束' : '遊戲暫停';
    ovMsg.textContent   = gameOver ? '小心紅色方塊，下次一定更久！' : '稍作休息，準備再出發。';
    ovScore.textContent = score; ovBest.textContent = best;
    btnResume.textContent = gameOver ? '再玩一次' : '繼續';
    btnPause.textContent  = p ? '繼續' : '暫停';
  }
  btnPause.onclick = ()=> setPause(running);
  btnResume.onclick = ()=> { if(gameOver) restart(); setPause(false); };
  btnRestart.onclick= ()=> restart();

  function restart(){
    enemies.length = 0;
    score = 0; gameOver = false;
    player.x = cvs.width/2 - player.w/2; player.vx=0;
    setPause(false);
  }

  // 主循環
  let last=0, acc=0, spawnT=0;
  function loop(t){
    requestAnimationFrame(loop);
    const dt = Math.min(32, t - last || 16); last = t;
    if(!running) return;

    // 更新
    acc += dt; spawnT += dt;
    if (spawnT > 500) { // 每0.5秒生成
      spawnT = 0;
      for(let i=0;i<1+Math.floor(score/6000);i++) spawnEnemy();
    }
    // 移動玩家
    const a = (keys['ArrowLeft']||keys['a']||keys['A']) ? -1 : (keys['ArrowRight']||keys['d']||keys['D']) ? 1 : 0;
    if(a) player.vx = a * player.speed;
    else if(!('ontouchstart' in window)) player.vx *= .85; // 慣性
    player.x = clamp(player.x + player.vx, 10, cvs.width - player.w - 10);

    // 移動敵人
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      e.x += e.vx; e.y += e.vy;
      if (hit(player, e)) {
        gameOver = true;
        best = Math.max(best, score|0);
        localStorage.setItem('best-dodge', best);
        bestEl.textContent = best;
        setPause(true);
      }
      if (e.x<-80||e.x>cvs.width+80||e.y>cvs.height+40) enemies.splice(i,1);
    }

    // 計分
    score += dt; scoreEl.textContent = (score/1000).toFixed(1);

    // 繪製
    ctx.clearRect(0,0,cvs.width,cvs.height);
    drawCircuitBG();
    drawPlayer();
    enemies.forEach(drawEnemy);

    // 提示開始
    if (score < 1500) {
      ctx.fillStyle = 'rgba(255,255,255,.75)';
      ctx.font = '700 14px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto';
      ctx.textAlign = 'center';
      ctx.fillText('左右移動以躲避紅色方塊', cvs.width/2, cvs.height/2-6);
    }
  }
  requestAnimationFrame(loop);

  // Esc 暫停
  addEventListener('keydown', e => { if(e.key==='Escape'){ setPause(running); } });
})();
</script>
</body>
</html>
