<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>籃球投籃遊戲</title>
<style>
  :root{--bg:#0b0f14;--panel:#121821;--fg:#e6edf3;--accent:#ffb703;--accent2:#25c2ff;}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial;}
  .wrap{height:100%;display:grid;grid-template-rows:auto 1fr auto;gap:.5rem;}
  header{padding:.6rem 1rem;background:linear-gradient(180deg,#111724,#0f1520);box-shadow:0 2px 8px rgba(0,0,0,.35);display:flex;align-items:center;justify-content:space-between}
  h1{font-size:1rem;margin:0;letter-spacing:.05em;color:#cfe3ff}
  .stats{display:flex;gap:1rem;align-items:center;font-variant-numeric:tabular-nums}
  .badge{background:#162033;border:1px solid #283049;color:#bcd1ff;padding:.25rem .5rem;border-radius:.5rem}
  .court{position:relative;display:grid;place-items:center}
  canvas{width:min(100vw,900px);height:calc(min(100vw,900px)*.6);max-height:70vh;background:
    radial-gradient(120% 120% at 80% 0%, #122133 0, #0f1826 50%, #0c1320 100%);
    border:1px solid #253047;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.45) inset}
  footer{display:grid;gap:.5rem;place-items:center;padding:.25rem .75rem 1rem}
  .controls{display:flex;gap:.5rem;flex-wrap:wrap;justify-content:center}
  button{background:#1a2436;border:1px solid #2b3750;color:#d8e6ff;padding:.55rem .8rem;border-radius:.6rem;cursor:pointer}
  button:active{transform:translateY(1px)}
  .primary{background:linear-gradient(180deg,#1e87ff,#0a6ad1);border-color:#2a72d9;color:white}
  .sliders{display:flex;gap:1rem;align-items:center;flex-wrap:wrap}
  .bar{width:200px;height:8px;border-radius:999px;background:#1a2231;position:relative;outline:1px solid #2a3346}
  .bar > i{position:absolute;inset:0;border-radius:999px;background:linear-gradient(90deg,var(--accent2),var(--accent))}
  .hint{opacity:.8;font-size:.9rem}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>🟦 籃球投籃</h1>
    <div class="stats">
      <div class="badge">Score：<span id="score">0</span></div>
      <div class="badge">Shots：<span id="shots">0</span></div>
      <div class="badge">Angle：<span id="angText">0°</span></div>
      <div class="badge">Power：<span id="powText">50%</span></div>
    </div>
  </header>

  <div class="court">
    <canvas id="cv" width="900" height="540"></canvas>
  </div>

  <footer>
    <div class="sliders">
      <div>角度</div>
      <div class="bar"><i id="barAngle" style="width:50%"></i></div>
      <div>力度</div>
      <div class="bar"><i id="barPower" style="width:50%"></i></div>
    </div>
    <div class="controls">
      <button id="btnLeft">← 左</button>
      <button id="btnRight">右 →</button>
      <button id="btnLess">力度 -</button>
      <button id="btnMore">力度 +</button>
      <button class="primary" id="btnShoot">SHOOT</button>
      <button id="btnReset">Reset</button>
    </div>
    <div class="hint">鍵盤：← → 調角度、↑ ↓ 調力度、空白鍵出手；或用下方按鈕。球停止後會自動回到出手點。</div>
  </footer>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  // ===== 常數與場景佈局 =====
  const G = 980;              // 重力 (px/s^2)
  const DT = 1/60;            // 固定時間步 (秒)
  const BALL_R = 12;          // 球半徑
  const RIM_R = 7;            // 籃框「金屬圈」的碰撞半徑，用作兩邊掛點
  const COEF = 0.65;          // 反彈係數
  const AIR = 0.0025;         // 簡單空阻

  // 尺度：畫布 900x540，出手點靠左下
  const shootPos = { x: 120, y: cv.height-80 };
  const backboard = { x: cv.width-160, y: cv.height*0.35, w: 8, h: 110 };
  const rim = {
    // 兩個圓點代表籃框左右掛點
    left:  { x: backboard.x-60, y: backboard.y+36 },
    right: { x: backboard.x-60+45, y: backboard.y+36 },
    // 判定得分的門框（矩形窗口）
    scoreTop: backboard.y+30,
    scoreBottom: backboard.y+60
  };

  // ===== 狀態 ====
  let angleDeg = 50;  // 15 ~ 80
  let power = 55;     // 10 ~ 100（百分比）
  let score = 0, shots = 0;

  const elScore = document.getElementById('score');
  const elShots = document.getElementById('shots');
  const elAng   = document.getElementById('angText');
  const elPow   = document.getElementById('powText');
  const barAngle= document.getElementById('barAngle');
  const barPower= document.getElementById('barPower');

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function uiSync(){
    elAng.textContent = Math.round(angleDeg) + '°';
    elPow.textContent = Math.round(power) + '%';
    barAngle.style.width = ((angleDeg-15)/(80-15))*100 + '%';
    barPower.style.width = (power/100)*100 + '%';
    elScore.textContent = score;
    elShots.textContent = shots;
  }

  // ===== 球物理 =====
  const ball = {
    x: shootPos.x, y: shootPos.y, vx: 0, vy: 0,
    shot: false, scored: false,
    reset(){
      this.x = shootPos.x; this.y = shootPos.y;
      this.vx = this.vy = 0; this.shot=false; this.scored=false;
    }
  };

  function shoot(){
    if(ball.shot) return;
    shots++; elShots.textContent = shots;
    // 將力度換成初速：最大力度對應 ~ 900 px/s
    const v = 250 + power/100 * 650;
    const a = angleDeg * Math.PI/180;
    ball.vx = Math.cos(a)*v;
    ball.vy = -Math.sin(a)*v;
    ball.shot = true;
  }

  // 圓-圓簡易碰撞反彈（球 vs 框掛點）
  function collideCircle(cx, cy, cr){
    const dx = ball.x - cx, dy = ball.y - cy;
    const dist = Math.hypot(dx,dy), minD = BALL_R + cr;
    if(dist < minD){
      const nx = dx/dist, ny = dy/dist;
      // 推離
      const pen = minD - dist;
      ball.x += nx * pen;
      ball.y += ny * pen;
      // 速度反射
      const vn = ball.vx*nx + ball.vy*ny;
      const vxr = ball.vx - (1+COEF)*vn*nx;
      const vyr = ball.vy - (1+COEF)*vn*ny;
      ball.vx = vxr; ball.vy = vyr;
    }
  }

  // 直線板（Backboard）碰撞（近似：垂直牆）
  function collideBoard(){
    const boardX = backboard.x;
    if(ball.x + BALL_R > boardX && ball.y > backboard.y && ball.y < backboard.y+backboard.h){
      ball.x = boardX - BALL_R;
      ball.vx = -Math.abs(ball.vx)*COEF;
    }
  }

  // 地板、牆面
  function collideWalls(){
    // 地板
    if(ball.y + BALL_R > cv.height-10){
      ball.y = cv.height-10 - BALL_R;
      ball.vy = -Math.abs(ball.vy)*COEF;
      // 水平摩擦
      ball.vx *= 0.9;
      if(Math.abs(ball.vx)<10 && Math.abs(ball.vy)<10){
        // 完全停下，自動重置
        setTimeout(()=>ball.reset(), 600);
      }
    }
    // 左牆
    if(ball.x - BALL_R < 5){
      ball.x = 5 + BALL_R; ball.vx = Math.abs(ball.vx)*COEF;
    }
    // 右牆（出界）
    if(ball.x - BALL_R > cv.width+60 || ball.y - BALL_R > cv.height+60){
      setTimeout(()=>ball.reset(), 400);
    }
  }

  // 得分判定：球心穿過籃框開口範圍，且在兩掛點之間，且向下
  function checkScore(){
    if(ball.scored) return;
    const withinX = ball.x > rim.left.x+RIM_R && ball.x < rim.right.x-RIM_R;
    const crossedDown = ball.vy > 0 && ball.y - BALL_R > rim.scoreTop && ball.y - BALL_R < rim.scoreBottom;
    if(withinX && crossedDown){
      ball.scored = true; score++; elScore.textContent = score;
      // 小加分特效：把垂直速度削弱一點讓它穿過去更順
      ball.vy *= 0.88;
    }
  }

  // ===== 更新與繪圖 =====
  function step(){
    // 物理
    if(ball.shot){
      // 空阻（非常簡單）
      ball.vx *= (1 - AIR);
      ball.vy *= (1 - AIR);
      // 重力
      ball.vy += G*DT;

      ball.x += ball.vx*DT;
      ball.y += ball.vy*DT;

      // 碰撞
      collideCircle(rim.left.x, rim.left.y, RIM_R);
      collideCircle(rim.right.x, rim.right.y, RIM_R);
      collideBoard();
      collideWalls();
      checkScore();
    }

    // 繪製
    draw();
    requestAnimationFrame(step);
  }

  function drawCourtLines(){
    // 半透明球場線
    ctx.save();
    ctx.strokeStyle = "rgba(180,210,255,.08)";
    ctx.lineWidth = 2;

    // 地板線
    ctx.beginPath();
    ctx.moveTo(0, cv.height-10);
    ctx.lineTo(cv.width, cv.height-10);
    ctx.stroke();

    // 罰球區（只畫裝飾）
    ctx.beginPath();
    ctx.arc(shootPos.x+120, cv.height-60, 70, Math.PI*1.1, Math.PI*1.95);
    ctx.stroke();
    ctx.restore();
  }

  function drawBackboardAndRim(){
    // Backboard
    ctx.save();
    ctx.fillStyle = "#dbe7ff";
    ctx.globalAlpha = .9;
    ctx.fillRect(backboard.x, backboard.y, backboard.w, backboard.h);
    ctx.restore();

    // Rim 橘色
    ctx.save();
    ctx.strokeStyle = "#ff8c1a";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(rim.left.x, rim.left.y);
    ctx.lineTo(rim.right.x, rim.right.y);
    ctx.stroke();

    // 掛點（碰撞點）
    ctx.fillStyle = "#ff8c1a";
    ctx.beginPath(); ctx.arc(rim.left.x, rim.left.y, 5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(rim.right.x, rim.right.y,5, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawBall(){
    // 球
    const grad = ctx.createRadialGradient(ball.x-6, ball.y-6, 4, ball.x, ball.y, BALL_R+6);
    grad.addColorStop(0, "#ffb703");
    grad.addColorStop(1, "#ff7a00");
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI*2);
    ctx.fill();

    // 球紋
    ctx.strokeStyle = "rgba(0,0,0,.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, BALL_R-3, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(ball.x - BALL_R, ball.y);
    ctx.lineTo(ball.x + BALL_R, ball.y);
    ctx.moveTo(ball.x, ball.y - BALL_R);
    ctx.lineTo(ball.x, ball.y + BALL_R);
    ctx.stroke();
  }

  function drawLauncher(){
    // 瞄準線
    const a = angleDeg*Math.PI/180;
    const len = 70 + (power/100)*30;
    const tx = shootPos.x + Math.cos(a)*len;
    const ty = shootPos.y - Math.sin(a)*len;

    ctx.save();
    ctx.strokeStyle = "rgba(37,194,255,.9)";
    ctx.lineWidth = 3;
    ctx.setLineDash([8,8]);
    ctx.beginPath();
    ctx.moveTo(shootPos.x, shootPos.y);
    ctx.lineTo(tx, ty);
    ctx.stroke();
    ctx.setLineDash([]);

    // 發射基座
    ctx.fillStyle = "#1d2a3f";
    ctx.fillRect(shootPos.x-22, shootPos.y+BALL_R, 44, 10);
    ctx.restore();

    // 出手點小圓
    ctx.fillStyle = "#25c2ff";
    ctx.beginPath();
    ctx.arc(shootPos.x, shootPos.y, 4, 0, Math.PI*2);
    ctx.fill();
  }

  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);

    // 背景微暈
    const g = ctx.createLinearGradient(0,0,0,cv.height);
    g.addColorStop(0, "#0d1725");
    g.addColorStop(1, "#0b121d");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,cv.width,cv.height);

    drawCourtLines();
    drawBackboardAndRim();
    drawLauncher();
    drawBall();
  }

  // ===== 操作 =====
  function setAngle(delta){
    angleDeg = clamp(angleDeg + delta, 15, 80);
    uiSync();
  }
  function setPower(delta){
    power = clamp(power + delta, 10, 100);
    uiSync();
  }

  window.addEventListener('keydown', (e)=>{
    if(e.code === 'ArrowLeft') setAngle(-2);
    if(e.code === 'ArrowRight') setAngle(+2);
    if(e.code === 'ArrowUp') setPower(+3);
    if(e.code === 'ArrowDown') setPower(-3);
    if(e.code === 'Space'){ e.preventDefault(); shoot(); }
  });

  // 按鈕
  document.getElementById('btnLeft').onclick = ()=>setAngle(-3);
  document.getElementById('btnRight').onclick = ()=>setAngle(+3);
  document.getElementById('btnLess').onclick = ()=>setPower(-5);
  document.getElementById('btnMore').onclick = ()=>setPower(+5);
  document.getElementById('btnShoot').onclick = ()=>shoot();
  document.getElementById('btnReset').onclick = ()=>{ ball.reset(); };

  // 簡單拖曳瞄準（桌面／手機）：從出手點拖曳決定角度與力度
  let dragging=false;
  cv.addEventListener('pointerdown', (ev)=>{
    const rect = cv.getBoundingClientRect();
    const x = (ev.clientX-rect.left)/rect.width * cv.width;
    const y = (ev.clientY-rect.top)/rect.height * cv.height;
    const dx = x - shootPos.x, dy = y - shootPos.y;
    if(Math.hypot(dx,dy) < 90) dragging=true; // 只允許在出手點附近開始拖曳
  });
  cv.addEventListener('pointermove', (ev)=>{
    if(!dragging) return;
    const rect = cv.getBoundingClientRect();
    const x = (ev.clientX-rect.left)/rect.width * cv.width;
    const y = (ev.clientY-rect.top)/rect.height * cv.height;
    let a = Math.atan2(shootPos.y - y, x - shootPos.x) * 180/Math.PI;
    a = clamp(a, 15, 80);
    angleDeg = a;
    const dist = clamp(Math.hypot(x-shootPos.x, y-shootPos.y), 40, 180);
    power = clamp(((dist-40)/(180-40))*100, 10, 100);
    uiSync();
  });
  window.addEventListener('pointerup', ()=>{
    if(dragging){ dragging=false; shoot(); }
  });

  uiSync();
  step();
})();
</script>
</body>
</html>
